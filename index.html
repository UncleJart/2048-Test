<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>2048 Test</title>
</head>
<style>
	.slide{
		display: flex;
		width: 1024px;
		height: 768px;
		background-color: lightgrey;
	}

	.gamefield{
		margin: auto;
		width: 500px;
		height: 500px;
		position: relative;
		border: 1px solid #000000;
	}

	.wrapper{
		position: absolute;
		top: 20px;
		left: 20px;
		height: 460px;
	}

	.column{
		width: 460px;
	}

	.background-wrapper{
		display: flex;
		flex-flow: column wrap;
		justify-content: space-between;
	}

	.background-wrapper .column{
		display: flex;
		flex-flow: row nowrap;
		justify-content: space-between;
	}

	.elements-wrapper .column{
		display: block;
	}

	.square{
		width: 100px;
		height: 100px;
	}

	.background-wrapper .square{
		background-color: #CDC1B4;
	}

	.elements-wrapper .square{
		position: absolute;
		background-color: transparent;
		text-align: center;
		vertical-align: middle;
		color: #FFFFFF;
		font: 900 normal 2em/100px Arial;
		transform: translateX(50px) translateY(50px);
	}

	.new-el-animation{
		animation: newElement .1s linear;
	}

	.inc-el-animation{
		animation: incElement .1s linear;
	}

	.transition{
		transition: transform .1s linear;
	}
	
	@keyframes newElement {
		from{
			transform: scale(0);
		}
		to{
			transform: scale(1);
		}
	}

	@keyframes incElement {
		from{
			transform: scale(1.5);
		}
		to{
			transform: scale(1);
		}
	}
</style>
<body>
	<article class="slide">
		<div class="gamefield">
			<div class="background-wrapper wrapper">
				<div class="column">
					<div class="square"></div>
					<div class="square"></div>
					<div class="square"></div>
					<div class="square"></div>
				</div>
				<div class="column">
					<div class="square"></div>
					<div class="square"></div>
					<div class="square"></div>
					<div class="square"></div>
				</div>
				<div class="column">
					<div class="square"></div>
					<div class="square"></div>
					<div class="square"></div>
					<div class="square"></div>
				</div>
				<div class="column">
					<div class="square"></div>
					<div class="square"></div>
					<div class="square"></div>
					<div class="square"></div>
				</div>
			</div>
			<div class="elements-wrapper wrapper" id="gameField">
				<div class="column">
					<div class="square element"></div>
					<div class="square element"></div>
					<div class="square element"></div>
					<div class="square element"></div>
				</div>
				<div class="column">
					<div class="square element"></div>
					<div class="square element"></div>
					<div class="square element"></div>
					<div class="square element"></div>
				</div>
				<div class="column">
					<div class="square element"></div>
					<div class="square element"></div>
					<div class="square element"></div>
					<div class="square element"></div>
				</div>
				<div class="column">
					<div class="square element"></div>
					<div class="square element"></div>
					<div class="square element"></div>
					<div class="square element"></div>
				</div>
			</div>
		</div>
	</article>
</body>
<script>
	var columnArray = [],
		valuesArray = [2,4];

//Utils
	function getRandom(min, max) {
		return Math.random() * (max - min) + min;
	}

	function getRoundedRandom(min,max,rounded){
		return rounded ?
				Math.round(getRandom(min,max)) :
				Math.floor(getRandom(min,max))
	}

	function decreaseArraySorting(a, b) {
		if (a > b){
			return -1;
		}
		if (a < b){
			return 1;
		}
		if (a = b){
			return 0;
		}
	}

	function increaseArraySorting(a, b) {
		if (a > b){
			return -1;
		}
		if (a < b){
			return 1;
		}
		if (a = b){
			return 0;
		}
	}

	function compareArrays(array1,array2){
		return array1.every(function(item,i){
			return array1[i] === array2[i];
		});
	}

	function convertNodeListToArray(nodeList,htmlElementType,resArray){
		Array.prototype.forEach.call(nodeList,function(item){
			if (item instanceof htmlElementType){
				resArray.push(item);
			}
		});
	}

	function getCssTransformMatrix(element){                                    //===========>>>>>>>>> Rewrite for full matrix decomposition
		var transformMatrix = window.getComputedStyle(element,null).transform,
				regExp = /\-?\d\.?\d*/gi;

		console.log(transformMatrix.match(regExp));
		return transformMatrix.match(regExp);
	}

	function getCssTranslateProperty(transformArray){                                    //===========>>>>>>>>> Rewrite for full matrix decomposition
		transformArray.forEach(function(item,i,array){
			array[i] = +item;
		});

		console.log(transformArray.slice(-2));
		return transformArray.slice(-2);
	}

	function checkForZeroTranslateProperty(element){
		return getCssTranslateProperty(getCssTransformMatrix(element)).every(function(item){
			return !item;
		});
	}
//Constructors
	function StartValues(options){
		this.startValues = [];

		options.values.forEach(function(item,i){
			var valueOpts = {};

			valueOpts.value = item;
			valueOpts.probability = options.probability[i];
			this.startValues.push(valueOpts);
		},this);
	}

	StartValues.prototype.getValue = function(){
		var startValue,
			probabilities = [],
			random = Math.random(),
			that = this;

		this.startValues.forEach(function(item){
			probabilities.push(item.probability);
		});

		probabilities.sort(decreaseArraySorting);

		probabilities.reduce(function(prev,curr,i){
			if (random > prev && random < (prev + curr)){
				startValue = that.startValues[i].value;
			}
			return prev + curr;
		},0);

		return startValue; // not needed

	};
//Objects for creating Game Field
	function GameField(numOfRows,numOfColumns,elementValues,numOfStartElements){
		var colCnt,rowCnt,rowArray,gFieldEl,
			startValue = "";

		numOfStartElements = numOfStartElements || 2;

		this.gameField = [];
		this.startValue = startValue;
		this.gameFieldIsFull = false;
		this.elementValues = new StartValues(elementValues);
		this.numOfStartElelements = numOfStartElements;

		for(colCnt = 0; colCnt < numOfColumns; colCnt++){        //rewrite
			rowArray = [];
			for(rowCnt = 0; rowCnt < numOfRows; rowCnt++){
				gFieldEl = {
					value : startValue,
					x: null,
					y: null,
					xPrev: null,
					yPrev: null,
					new: false,
					inc: false
				};
				rowArray.push(gFieldEl);
			}
			this.gameField.push(rowArray);
		}
	}
//Methods of Game Field
//Генерация элемента
	GameField.prototype.generateElement = function(){
		var position,column,row;

		do{
			position = this.generateElementPosition();
			column = position[0];
			row = position[1];
		}while(!this.checkIfElementIsEmpty(position));

		this.gameField[column][row].value = this.elementValues.getValue();

		//code to obtain element position

		this.gameField[column][row].x = row;
		this.gameField[column][row].y = column;
		this.gameField[column][row].new = true;

		return position;
	};
//Генерация стартовых элементов
	GameField.prototype.generateStartElements = function(){
		var cnt;

		for(cnt = 1; cnt <= this.numOfStartElelements; cnt++){
			this.generateElement();
		}

		printArray(this);
	};
//Проверка на пустое поле, т.е. равно ли поле начальному значению
	GameField.prototype.checkForFullGameField = function(){
		return this.gameField.every(function(item){
			return item.every(function(item){
				return item.value !== this.startValue;
			},this);
		},this) && !this.checkForPossibleRowMerge() && !this.checkForPossibleColumnMerge();
	};

	GameField.prototype.checkForPossibleMerge = function(){
		return this.gameField.some(function(item){
			return item.some(function(item,i,array){
				return item.value !== this.startValue && array[i+1] && item.value === array[i+1].value;
			},this);
		},this);
	};

	GameField.prototype.checkForPossibleRowMerge = function(){
		return this.checkForPossibleMerge();
	};

	GameField.prototype.checkForPossibleColumnMerge = function(){
		var possColumnMerge;
		this.gameField = reverseArray(this.gameField);
		possColumnMerge = this.checkForPossibleMerge();
		this.gameField = reverseArray(this.gameField);
		return possColumnMerge;
	};
//Генерация случайной позиции элемента
	GameField.prototype.generateElementPosition = function(){
		var position = [],
			columns = this.gameField.length - 1,
			rows = this.gameField[0].length - 1;

		position.push(getRoundedRandom(0,columns,true));
		position.push(getRoundedRandom(0,rows,true));
		return position;
	};
//Проверка на соответствие элемента начальному значению
	GameField.prototype.checkIfElementIsEmpty = function(position){
		var column = position[0],
			row = position[1];
		return this.gameField[column][row].value === this.startValue;
	};
//Получить значения игрового поля
	GameField.prototype.getValues = function(){
		var values = [];
		this.gameField.forEach(function(row){
			row.forEach(function(item){
				values.push(item.value);
			});
		});
		return values;
	};

	GameField.prototype.reverseCoordinates = function(){
		this.gameField.forEach(function(row){
			row.forEach(function(item,i,array){
				var x = item.x,
					xPrev = item.xPrev;
				array[i].x = item.y;
				array[i].y = x;
				array[i].xPrev = item.yPrev;
				array[i].yPrev = xPrev;
			});
		});
	};
//Сдвиг элементов горизонтально (вправо или влево)
	GameField.prototype.moveHorizontally = function(moveStraight){
		var gFieldValues;
		if(!this.gameFieldIsFull){
			gFieldValues = this.getValues();
			this.savePreviousPositions();
			this.reverseCoordinates();
			moveGameField(this,moveStraight);
			this.reverseCoordinates();
			if(!compareArrays(gFieldValues,this.getValues())){
				this.generateElement();
			}
			this.gameFieldIsFull = this.checkForFullGameField();
		}

		printArray(this);
	};

	GameField.prototype.moveVertically = function(moveStraight){ //Add check for not changed gamefield
		var gFieldValues;
		if(!this.gameFieldIsFull){
			gFieldValues = this.getValues();
			this.savePreviousPositions();
			this.gameField = reverseArray(this.gameField);
			moveStraight = !moveStraight;
			moveGameField(this,moveStraight);
			this.gameField = reverseArray(this.gameField);
			if(!compareArrays(gFieldValues,this.getValues())){
				this.generateElement();
			}
			this.gameFieldIsFull = this.checkForFullGameField();
		}

		printArray(this);
	};

	GameField.prototype.savePreviousPositions = function(){
		this.gameField.forEach(function(row){
			row.forEach(function(item){
				item.xPrev = item.x;
				item.yPrev = item.y;
			});
		});
	};

	function moveGameField(targetFieldObj,moveStraight){    //add column
		targetFieldObj.gameField.forEach(function(item,column){
			var row = item,
				options = setArrayShiftOptions(moveStraight,row);
			moveAndMergeElementsOfArray(targetFieldObj,column,row,options);
		});
	}

	function setArrayShiftOptions(moveStraight,row){
		var options = {};
		if(moveStraight){
			options.startPoint = row.length - 1;
			options.endPoint = 0;
			options.step = -1;
			options.check = function(cnt){
				return cnt >= this.endPoint;
			}
		}else{
			options.startPoint = 0;
			options.endPoint = row.length - 1;
			options.step = 1;
			options.check = function (cnt) {
				return cnt <= this.endPoint;
			}
		}
		return options;
	}
//Change array "rotation"
	function reverseArray(targetArray){
		var reverseArray = [],
			newRow;
		targetArray[0].forEach(function(_,i){
			newRow = [];
			targetArray.forEach(function(item2){
				newRow.push(item2[i]);
			});
			reverseArray.push(newRow);
		});
		return reverseArray;
	}
//Ф-ии для сдвига элементов массива
	function moveAndMergeElementsOfArray(targetObj,column,row,options){
		var startValue = targetObj.startValue;

		moveElementsOfArray(column,row,startValue,options);
		mergeElementsOfArray(column,row,startValue,options);

		return row;
	}

	function moveElementsOfArray(column,row,startValue,options){
		var startPoint = options.startPoint,
			step = options.step,
			lastEmptyElPos = null,
			cnt;

		for(cnt = startPoint; options.check(cnt); cnt += step){
			lastEmptyElPos = setStartEmptyElement(row,startValue,cnt,lastEmptyElPos);

			if(row[cnt].value !== startValue && cnt !== startPoint && lastEmptyElPos !== null){
				lastEmptyElPos = makeArrayReshuffle(column,row,cnt,startValue,lastEmptyElPos,options);
			}

		}
	}

	function mergeElementsOfArray(column,row,startValue,options){
		var startPoint = options.startPoint,
			step = options.step,
			cnt;
		for(cnt = startPoint; options.check(cnt); cnt += step) {
			if(row[cnt].value !== startValue && row[cnt + step] && row[cnt].value === row[cnt + step].value){
				row[cnt].value += row[cnt + step].value;
				row[cnt].inc = true;
				row[cnt + step].value = startValue; //to separate function ===================>>>>>>>>>>>>>>>>>>>>  !!!!!!!!!!!!!!!!!!!!
				row[cnt + step].x = null; //change to -1
				row[cnt + step].y = null; //change to -1
				row[cnt + step].xPrev = null;  //??
				row[cnt + step].yPrev = null;  //??
				row[cnt + step].new = false;   //Add some check or variable for changed element
				row[cnt + step].inc = false;   //Add some check or variable for changed element
			}
		}
		moveElementsOfArray(column,row,startValue,options);
	}

	function makeArrayReshuffle(column,row,elPos,startValue,lastEmptyElPos,options){

		lastEmptyElPos = getLatestEmptyElementPos(row,startValue,lastEmptyElPos,options);
		row[lastEmptyElPos].value = row[elPos].value;
		row[lastEmptyElPos].xPrev = row[elPos].xPrev;
		row[lastEmptyElPos].yPrev = row[elPos].yPrev;   //maybe rewrite for object copy
		row[lastEmptyElPos].x = column;
		row[lastEmptyElPos].y = lastEmptyElPos;
		row[elPos].value = startValue;
		row[elPos].x = null;
		row[elPos].y = null;
		row[elPos].xPrev = null;
		row[elPos].yPrev = null;
		lastEmptyElPos = elPos;
		return lastEmptyElPos;
	}

	function setStartEmptyElement(row,startValue,elPos,lastEmptyElPos){
		if(row[elPos].value === startValue && lastEmptyElPos === null){
			lastEmptyElPos = elPos;
		}
		return lastEmptyElPos;
	}

	function getLatestEmptyElementPos(row,startValue,lastEmptyElPos,options){
		var startPoint = options.startPoint,
			endPoint = options.endPoint;

		if(startPoint > endPoint) {
			lastEmptyElPos = getLastInRowEmptyElement(row,startValue,lastEmptyElPos,true);
		}else{
			lastEmptyElPos = getLastInRowEmptyElement(row,startValue,lastEmptyElPos,false);
		}
		return lastEmptyElPos;
	}


	function getLastInRowEmptyElement(row,startValue,lastEmptyElPos,moveStraight){
		var step = moveStraight ? 1 : -1;

		while(row[lastEmptyElPos] && row[lastEmptyElPos].value === startValue){
			lastEmptyElPos += step;
		}
		lastEmptyElPos -= step;
		return lastEmptyElPos;
	}

//Ф-ия для проверки пустых строк

	function printArray(array){
		var str = "";
		array.gameField.forEach(function(item){
			item.forEach(function(item){
				str+= "\""+item.value+"\"\t";
			});
			str += "\n";
		});
		str += "\n";
		array.gameField.forEach(function(item){ //remove later
			item.forEach(function(item){
				str+= "\""+item.x+","+item.y+"\"\t";
			});
			str += "\n";
		});
		str += "\n";
		array.gameField.forEach(function(item){ //remove later
			item.forEach(function(item){
				str+= "\""+item.xPrev+","+item.yPrev+"\"\t";
			});
			str += "\n";
		});
		console.log(str);
	}

	function handleKeyCode(gameField,keyCode,moveStraight){
		switch(keyCode) {
			case 38:
			{
				console.log("up");
				gameField.moveVertically(moveStraight);
				break;
			}
			case 40:
			{
				console.log("down");
				gameField.moveVertically(moveStraight);
				break;
			}
			case 37:
			{
				console.log("left");
				gameField.moveHorizontally(moveStraight);
				break;
			}
			case 39:
			{
				console.log("right");
				gameField.moveHorizontally(moveStraight);
				break;
			}
		}
	}

//Functions for work with DOM ======>>>>>>> future binder
	function createGameFieldElementsArray(gFieldElList,parentNode){
		var gFieldColumnElList = [],
			columnElements = parentNode.childNodes;

		convertNodeListToArray(columnElements,HTMLDivElement,gFieldColumnElList);

		gFieldColumnElList.forEach(function(item,i){
			var rowElements = item.childNodes,
				rowArr = [];

			gFieldElList.push(rowArr);
			convertNodeListToArray(rowElements,HTMLDivElement,gFieldElList[i]);
		});
	}

	function setGameFieldValues(gFieldList,gameFieldObj){
		gFieldList.forEach(function(rowArr,i){
			var column = gameFieldObj.gameField[i];
			rowArr.forEach(function(item,index){
				var row = column[index];
				item.innerHTML = row.value;
			});
		});
	}

	function setGameFieldElCoordinates(gFieldList,gameFieldObj,firstTime){ //fix smth about height of gamefield, mb attributes must be set from Javascript
		var firstGFieldEl = gFieldList[0][0],
			numOfElInRow = gFieldList[0].length,
			parentNode = firstGFieldEl.parentNode,
			rowWidth = getOnlyDigitsFromCSSProperty(parentNode,"width"),
			elWidth = getOnlyDigitsFromCSSProperty(firstGFieldEl,"width"),
			step = elWidth + ((rowWidth - (elWidth * numOfElInRow)) / (numOfElInRow - 1));

		gFieldList.forEach(function(rowArr,i){
			var row = gameFieldObj.gameField[i];
			rowArr.forEach(function(item,index){
				var el = row[index],
					position,xDiff,yDiff,listener;
				//Обнуление
				item.style.left = 0;
				item.style.top = 0;
				item.classList.remove("transition");
				item.classList.remove("inc-el-animation");
				//add some code to make transition work like it should
				item.style.transition = null; //to css
				item.style.transform = "translateX(0px) translateY(0px)"; //translate(0px)???
				window.getComputedStyle(item,null).transform; // hack to previous string work
				if(el.value){
					if(!el.new){
						item.classList.remove("new-el-animation");
						xDiff = el.x - el.xPrev;
						yDiff = el.y - el.yPrev;
						item.style.left = el.xPrev * step + "px";
						item.style.top = el.yPrev * step + "px";
						item.classList.add("transition");
						position = "translateX("+xDiff * step + "px) translateY("+ yDiff * step + "px)"; //add some code to make transition work like it should
						item.style.transform = position;

						if(el.inc){
							if(!xDiff && !yDiff){
								item.classList.add("inc-el-animation");
								el.inc = !el.inc;
							}else{
								item.addEventListener("transitionend",somefunc,false);
								el.inc = !el.inc;
							}
						}

						function somefunc(event){
							item.removeEventListener("transitionend",somefunc,false);
							item.classList.remove("transition");
							item.style.transform = "translateX(0px) translateY(0px)";
							item.style.left = el.x * step + "px";
							item.style.top = el.y * step  + "px";
							item.classList.add("inc-el-animation");
						}
					}else{
						item.style.visibility = "hidden";
						item.style.left = el.x * step + "px";
						item.style.top = el.y * step + "px";
						//add animation for new element =============>>>>>>>>>>>>>> HERE!!!!!!!
						if(firstTime){
							item.style.visibility = "visible";
							item.classList.add("new-el-animation");
						}else{
							document.addEventListener("transitionend",somefunc2,false);
							document.addEventListener("animationend",somefunc2,false);
						}
						el.new = !el.new;
						//item.addEventListener("transitionend",somefunc2,false);

						function somefunc2(){
							console.log("somefunc2 transition end");
							document.removeEventListener("transitionend",somefunc2,false);
							document.removeEventListener("animationend",somefunc2,false);
							item.style.visibility = "visible";
							item.classList.add("new-el-animation");
						}
					}
				}
			});
		});
	}

	function setGameFieldElColor(gFieldList,gameFieldObj){
		var color;

		gFieldList.forEach(function(rowArr,i){
			var column = gameFieldObj.gameField[i];
			rowArr.forEach(function(item,index){
				var row = column[index];
				color = setElementColor(row.value);
				item.style.backgroundColor = color;
			});
		});
	}

	function setElementColor(elValue){
		var colors = ["#EEE4DA","#EDE0C8","#F2B179","#F59563","#F67C5F","#F65E3B","#EDCF72","#EDBF32"],
			colorsLength = colors.length,
			colorIndex,
			log2Value;
		if(!elValue){
			return "transparent";
		}else{
			log2Value = Math.log2(elValue);
		}
		if (log2Value <= colorsLength){
			colorIndex = log2Value - 1;
		}else{
			colorIndex = log2Value % colorsLength;
			if(!(log2Value % colorsLength)){
				colorIndex = colorsLength - 1;
			}else{
				colorIndex--;
			}
		}
		return colors[colorIndex];
	}

	function drawGameField(gFieldList,gameFieldObj,firstTime){ //add needed functions
		setGameFieldValues(gFieldList,gameFieldObj);
		setGameFieldElColor(gFieldList,gameFieldObj);
		setGameFieldElCoordinates(gFieldList,gameFieldObj,firstTime);
	}

	function getOnlyDigitsFromCSSProperty(element,property){
		var regExp = /[0-9]/gi,
			propertyValue = window.getComputedStyle(element,null)[property];

		return Number(propertyValue.match(regExp).join(""));
	}


	function startGame(){
		var startOptions = {
			values : [2,4],
			probability :[0.9,0.1]
			},
			getDirection = null,
			gameOver = false;

		function init(){
			var gameField = new GameField(4,4,startOptions,2),  //=========>>>>>>>>>> Place to change gamefield dimensions and number of start elements
				gameFieldElement = document.getElementById("gameField"),
				gFieldList = [];

			createGameFieldElementsArray(gFieldList,gameFieldElement);  //======>>>>>>> Creating DOM Elements GameField Array

			gameField.generateStartElements();
			drawGameField(gFieldList,gameField,true);  //first launch - must be some value else????
			getDirection = document.addEventListener("keyup",keyListener);


			function keyListener(event){ //Must be swipeLeft/swipeRight
				var keyCode = event.keyCode,
						moveStraight;

				event.preventDefault();

				if(keyCode === 38 || keyCode === 39){
					moveStraight = true;
				}

				handleKeyCode(gameField,keyCode,moveStraight);

				if (keyCode === 37 || keyCode === 38 || keyCode === 39 || keyCode === 40){  //Must been changed === to many code ....
					drawGameField(gFieldList,gameField);
				}

				if (gameField.gameFieldIsFull){
					getDirection = document.removeEventListener("keyup",keyListener);

					document.onclick = function(event){
						if(event){
							document.onclick = null;
							startGame();
						}
					}
				}
			}
		}

		init();
	}

	startGame();

</script>
</html>