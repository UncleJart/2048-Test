<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>2048 Test</title>
</head>
<style>
	.slide{
		display: flex;
		width: 1024px;
		height: 768px;
		background-color: lightgrey;
	}

	.game-field{
		margin: auto;
		display: flex;
		flex-flow: column wrap;
		justify-content: space-around;
		width: 480px;
		height: 480px;
	}

	.column{
		display: flex;
		flex-flow: row nowrap;
		width: 480px;
		justify-content: space-around;
	}

	.square{
		border: 1px solid black;
		width: 100px;
		height: 100px;
		background-color: grey;
	}
</style>
<body>
	<article class="slide">
		<div id="gameField" class="game-field">
			<div class="column">
				<div class="square"></div>
				<div class="square"></div>
				<div class="square"></div>
				<div class="square"></div>
			</div>
			<div class="column">
				<div class="square"></div>
				<div class="square"></div>
				<div class="square"></div>
				<div class="square"></div>
			</div>
			<div class="column">
				<div class="square"></div>
				<div class="square"></div>
				<div class="square"></div>
				<div class="square"></div>
			</div>
			<div class="column">
				<div class="square"></div>
				<div class="square"></div>
				<div class="square"></div>
				<div class="square"></div>
			</div>
		</div>
	</article>
</body>
<script>
	var columnArray = [],
		valuesArray = [2,4];

//Utils
	function getRandom(min, max) {
		return Math.random() * (max - min) + min;
	}

	function getRoundedRandom(min,max,rounded){
		return rounded ?
				Math.round(getRandom(min,max)) :
				Math.floor(getRandom(min,max))
	}

	function decreaseArraySorting(a, b) {
		if (a > b){
			return -1;
		}
		if (a < b){
			return 1;
		}
		if (a = b){
			return 0;
		}
	}

	function increaseArraySorting(a, b) {
		if (a > b){
			return -1;
		}
		if (a < b){
			return 1;
		}
		if (a = b){
			return 0;
		}
	}
//Constructors
	function StartValues(options){
		this.startValues = [];

		options.values.forEach(function(item,i){
			var valueOpts = {};

			valueOpts.value = item;
			valueOpts.probability = options.probability[i];
			this.startValues.push(valueOpts);
		},this);
	}

	StartValues.prototype.getValue = function(){
		var startValue,
			probabilities = [],
			random = Math.random(),
			that = this;

		this.startValues.forEach(function(item){
			probabilities.push(item.probability);
		});

		probabilities.sort(decreaseArraySorting);

		probabilities.reduce(function(prev,curr,i){
			if (random > prev && random < (prev + curr)){
				startValue = that.startValues[i].value;
			}
			return prev + curr;
		},0);

		return startValue; // not needed

	};
//Objects for creating Game Field
	function GameField(numOfRows,numOfColumns,elementValues,numOfStartElements){
		var cnt,cnt2,rowArray,gFieldEl,
			startValue = "",
			numOfElements = numOfRows * numOfColumns;

		numOfStartElements = numOfStartElements || 2;

		this.gameField = [];
		this.startValue = startValue;
		this.gameFieldIsFull = false;
		this.elementValues = new StartValues(elementValues);
		this.numOfStartElelements = numOfStartElements;

		for(cnt = 0; cnt < numOfColumns; cnt++){        //rewrite
			rowArray = [];
			for(cnt2 = 0; cnt2 < numOfRows; cnt2++){
				gFieldEl = {
					value : startValue,
					x: null,
					y: null
				};
				rowArray.push(gFieldEl);
			}
			this.gameField.push(rowArray);
		}
	}
//Methods of Game Field
//Генерация элемента
	GameField.prototype.generateElement = function(){
		var position,column,row,index;

		do{
			position = this.generateElementPosition();
			column = position[0];
			row = position[1];
		}while(!this.checkIfElementIsEmpty(position));

		this.gameField[column][row].value = this.elementValues.getValue();

		//code to obtain element position

		this.gameField[column][row].x = row;
		this.gameField[column][row].y = column;

		return position;
	};
//Генерация стартовых элементов
	GameField.prototype.generateStartElements = function(){
		var counter;

		for(counter = 1; counter <= this.numOfStartElelements; counter++){
			this.generateElement();
		}

		printArray(this);
	};
//Проверка на пустое поле, т.е. равно ли поле начальному значению
	GameField.prototype.checkForFullGameField = function(){
		return this.gameField.every(function(item){
			return item.every(function(item){
				return item.value !== this.startValue;
			},this);
		},this);
	};
//Генерация случайной позиции элемента
	GameField.prototype.generateElementPosition = function(){
		var position = [],
			columns = this.gameField.length - 1,
			rows = this.gameField[0].length - 1;

		position.push(getRoundedRandom(0,columns,true));
		position.push(getRoundedRandom(0,rows,true));
		return position;
	};
//Проверка на соответствие элемента начальному значению
	GameField.prototype.checkIfElementIsEmpty = function(position){
		var column = position[0],
			row = position[1];
		return this.gameField[column][row].value === this.startValue;
	};
//Сдвиг элементов горизонтально (вправо или влево)
	GameField.prototype.moveHorizontally = function(moveStraight){
		if(!this.gameFieldIsFull){
			moveGameField(this,moveStraight);
			this.generateElement();
			this.gameFieldIsFull = this.checkForFullGameField();
		}
		printArray(this);
	};

	GameField.prototype.moveVertically = function(moveStraight){
		if(!this.gameFieldIsFull){
			this.gameField = reverseArray(this.gameField);
			moveStraight = !moveStraight;
			moveGameField(this,moveStraight);
			this.gameField = reverseArray(this.gameField);
			this.generateElement();
			this.gameFieldIsFull = this.checkForFullGameField();
		}
		printArray(this);
	};

	function moveGameField(targetFieldObj,moveStraight){    //add column
		targetFieldObj.gameField.forEach(function(item,column){
			var row = item,
				options = setArrayShiftOptions(moveStraight,row);
			moveAndMergeElementsOfArray(targetFieldObj,column,row,options);
		});
	}

	function setArrayShiftOptions(moveStraight,row){
		var options = {};
		if(moveStraight){
			options.startPoint = row.length - 1;
			options.endPoint = 0;
			options.step = -1;
			options.check = function(cnt){
				return cnt >= this.endPoint;
			}
		}else{
			options.startPoint = 0;
			options.endPoint = row.length - 1;
			options.step = 1;
			options.check = function (cnt) {
				return cnt <= this.endPoint;
			}
		}
		return options;
	}
//Change array "rotation"
	function reverseArray(targetArray){
		var reverseArray = [],
			newRow;
		targetArray[0].forEach(function(_,i){
			newRow = [];
			targetArray.forEach(function(item2){
				newRow.push(item2[i]);
			});
			reverseArray.push(newRow);
		});
		return reverseArray;
	}
//Ф-ии для сдвига элементов массива
	function moveAndMergeElementsOfArray(targetObj,column,row,options){
		var startValue = targetObj.startValue;

		moveElementsOfArray(column,row,startValue,options);
		mergeElementsOfArray(column,row,startValue,options);

		return row;
	}

	function moveElementsOfArray(column,row,startValue,options){
		var startPoint = options.startPoint,
			step = options.step,
			lastEmptyElPos = null,
			cnt;

		for(cnt = startPoint; options.check(cnt); cnt += step){
			lastEmptyElPos = setStartEmptyElement(row,startValue,cnt,lastEmptyElPos);

			if(row[cnt].value !== startValue && cnt !== startPoint){
				if(lastEmptyElPos !== null){
					lastEmptyElPos = makeArrayReshuffle(column,row,cnt,startValue,lastEmptyElPos,options);
				}
			}
		}
	}

	function mergeElementsOfArray(column,row,startValue,options){
		var startPoint = options.startPoint,
			step = options.step,
			cnt,mark;
		for(cnt = startPoint; options.check(cnt); cnt += step) {
			if(row[cnt].value !== startValue && row[cnt + 1]){
				if(!mark && row[cnt].value === row[cnt + 1].value) {
					row[cnt].value += row[cnt + 1].value;
					row[cnt + 1].value = startValue;
					row[cnt + 1].x = null; //change to -1
					row[cnt + 1].y = null; //change to -1
					mark = !mark;
				}
				if(mark && row[cnt].value !== row[cnt + 1].value){
					mark = !mark;
				}
			}
		}
		moveElementsOfArray(column,row,startValue,options);
	}

	function makeArrayReshuffle(column,row,elPos,startValue,lastEmptyElPos,options){

		lastEmptyElPos = getLatestEmptyElementPos(row,startValue,lastEmptyElPos,options);
		row[lastEmptyElPos].value = row[elPos].value;
		row[lastEmptyElPos].x = column;
		row[lastEmptyElPos].y = lastEmptyElPos;
		row[elPos].value = startValue;
		row[elPos].x = null;
		row[elPos].y = null;
		lastEmptyElPos = elPos;
		return lastEmptyElPos;
	}

	function setStartEmptyElement(row,startValue,elPos,lastEmptyElPos){
		if(row[elPos].value === startValue){
			if(lastEmptyElPos === null){
				lastEmptyElPos = elPos;
			}
		}
		return lastEmptyElPos;
	}

	function getLatestEmptyElementPos(row,startValue,lastEmptyElPos,options){
		var startPoint = options.startPoint,
			endPoint = options.endPoint;

		if(startPoint > endPoint) {
			lastEmptyElPos = getLastInRowEmptyElement(row,startValue,lastEmptyElPos,true);
		}else{
			lastEmptyElPos = getLastInRowEmptyElement(row,startValue,lastEmptyElPos,false);
		}
		return lastEmptyElPos;
	}


	function getLastInRowEmptyElement(row,startValue,lastEmptyElPos,moveStraight){
		var step = moveStraight ? 1 : -1;

		while(row[lastEmptyElPos] && row[lastEmptyElPos].value === startValue){
			lastEmptyElPos += step;
		}
		lastEmptyElPos -= step;
		return lastEmptyElPos;
	}

//Ф-ия для проверки пустых строк

	function printArray(array){
		var str = "";
		array.gameField.forEach(function(item){
			item.forEach(function(item){
				str+= "\""+item.value+"\"\t";
			});
			str += "\n";
		});
		array.gameField.forEach(function(item){ //remove later
			item.forEach(function(item){
				str+= "\""+item.x+","+item.y+"\"\t";
			});
			str += "\n";
		});
		console.log(str);
	}

	function handleKeyCode(gameField,keyCode,moveStraight){
		switch(keyCode) {
			case 38:
			{
				console.log("up");
				gameField.moveVertically(moveStraight);
				break;
			}
			case 40:
			{
				console.log("down");
				gameField.moveVertically(moveStraight);
				break;
			}
			case 37:
			{
				console.log("left");
				gameField.moveHorizontally(moveStraight);
				break;
			}
			case 39:
			{
				console.log("right");
				gameField.moveHorizontally(moveStraight);
				break;
			}
		}
	}

	function startGame(){
		var startOptions = {
			values : [2,4],
			probability :[0.9,0.1]
			},
			getDirection = null,
			gameOver = false;

		function init(){
			var gameField = new GameField(4,4,startOptions,2);  //---> to 2

			gameField.generateStartElements();
			getDirection = document.addEventListener("keyup",keyListener);

			function keyListener(event){ //Must be swipeLeft/swipeRight
				var keyCode = event.keyCode,
						moveStraight;

				event.preventDefault();

				if(keyCode === 38 || keyCode === 39){
					moveStraight = true;
				}

				handleKeyCode(gameField,keyCode,moveStraight);

				if (gameField.gameFieldIsFull){
					getDirection = document.removeEventListener("keyup",keyListener);

					document.onclick = function(event){
						if(event){
							startGame();
						}
					}
				}
			}
		}

		init();
	}

	startGame();

</script>
</html>